install.packages("RCpp")
install.packages("Rcpp")
onedigits=c(-9:-1, 1:9);
ponedigits=c(1:9);
for (aa in ponedigits) {
for (bb in onedigits) {
for (cc in ponedigits) {
if (aa > cc) next;
for (dd in onedigits) {
for (ee in onedigits) {
for (ff in onedigits) {
detff = aa*dd-bb*cc;
if (detff ==0) next;
xx = (dd*ee - bb*ff) / detff;
yy = (-cc*ee + aa*ff) / detff;
if ((is.element(xx,onedigits) && (is.element(yy,onedigits))));
cat(sprintf('a=%d, b=%d, c=%d, d=%d, e=%d, f=%d, x=%d, y=%d\n',aa,bb,cc,dd,ee,ff,xx,yy));
}
}
}
}
}
}
for (aa in ponedigits) {
for (bb in onedigits) {
for (cc in ponedigits) {
if (aa > cc) next;
for (dd in onedigits) {
for (ee in onedigits) {
for (ff in onedigits) {
detff = aa*dd-bb*cc;
if (detff ==0) next;
xx = (dd*ee - bb*ff) / detff;
yy = (-cc*ee + aa*ff) / detff;
if ((is.element(xx,onedigits) && (is.element(yy,onedigits)))) {
cat(sprintf('a=%d, b=%d, c=%d, d=%d, e=%d, f=%d, x=%d, y=%d\n',aa,bb,cc,dd,ee,ff,xx,yy));
}
}
}
}
}
}
}
onedigits=c(-9:-1, 1:9);
ponedigits=c(1:9);
one=c(1);
for (aa in one) {
for (bb in onedigits) {
for (cc in ponedigits) {
if (aa > cc) next;
for (dd in onedigits) {
for (ee in onedigits) {
for (ff in onedigits) {
detff = aa*dd-bb*cc;
if (detff ==0) next;
xx = (dd*ee - bb*ff) / detff;
yy = (-cc*ee + aa*ff) / detff;
if ((is.element(xx,onedigits) && (is.element(yy,onedigits)))) {
cat(sprintf('a=%d, b=%d, c=%d, d=%d, e=%d, f=%d, x=%d, y=%d\n',aa,bb,cc,dd,ee,ff,xx,yy));
}
}
}
}
}
}
}
onedigits=c(-5:-1, 1:5);
ponedigits=c(1:5);
one=c(1);
for (aa in one) {
for (bb in onedigits) {
for (cc in ponedigits) {
if (aa > cc) next;
for (dd in onedigits) {
for (ee in onedigits) {
for (ff in onedigits) {
detff = aa*dd-bb*cc;
if (detff ==0) next;
xx = (dd*ee - bb*ff) / detff;
yy = (-cc*ee + aa*ff) / detff;
if ((is.element(xx,onedigits) && (is.element(yy,onedigits)))) {
cat(sprintf('a=%d, b=%d, c=%d, d=%d, e=%d, f=%d, x=%d, y=%d\n',aa,bb,cc,dd,ee,ff,xx,yy));
}
}
}
}
}
}
}
library(pROC)
install.packages(pROC)
install.packages('pROC'')
''
install.packages('pROC')
alibrary(pROC)
library(pROC)
data(aSAH)
ls()
aSAH
roc(aSAH$outcome, aSAH$s100b)
roc(aSAH$outcome, aSAH$s100b, levels=C("Good","Poor"))
roc(aSAH$outcome, aSAH$s100b, levels=C("Good","Poor"))
roc(outcome ~ s100b, aSAH)
with(aSAH, roc(outcome, s100b))
roc(outcome ~ s100b, data=aSAH)
roc(controls = aSAH$s100b[aSAH$outcome =="GOOD"], cases = aSAH$s100b[aSAH$outcome=="POOR"])
roc(controls = aSAH$s100b[aSAH$outcome =="Good"], cases = aSAH$s100b[aSAH$outcome=="Poor"])
roc(aSAH$outcome, aSAH$s100b, percent=T, plot=T, ci=T)
head(aSAH$outcome)
head(aSAH)
roc(aSAH$outcome, aSAH$ndka, percent=T, plot=T, ci=T)
setwd("C:/Users/baeks/Google Drive/Research/R")
setwd("~/")
1 / (3.72e-7)
source("http://bioconductor.org/biocLite.R")
biocLite("BSgenome.Mmusculus.UCSC.mm9")
bases = c('A','C','G','T');
nbases = length(bases);
npos = 6;
nAPC = nbases ** npos;
imat = array(0, dim=c(nAPC, npos))
for (i in 1:nAPC) {
mult = i-1;
for (kk in 1:npos) {
r = mult %% nbases;
imat[i,npos-kk+1]= r+1;
mult = mult - r;
mult = mult / nbases;
}
}
imat
rn
rnorm
sp=c(rep(0,100),abs(rnorm(100,mean=5,sd=10)), 200);
sp
quantile
help(quantile)
quantile(sp)
ecdf(sp)
fff=ecdf(sp)
fff(0)
fff(1)
fff(3)
fff(5)
apply(sp, ecdf)
sapply(sp, ecdf)
sapply(sp, fff)
plot.ecdf(sp)
pctile=sapply(sp,sp_ecdf)
sp=c(rep(0,100),abs(rnorm(100,mean=5,sd=10)), 200);
sp_ecdf= ecdf(sp);
pctile=sapply(sp,sp_ecdf)
pctile
plot(pctile)
plot(sort(pctile))
array2=matrix(0, dim=c(5,5));
array2=matrix(0, c(5,5));
array2
help(matrix)
array
help(array)
array2=array(0, dim=c(5,5));
array2
flatten
resize
redim
dim(array2)
dim(array2) <- c(1,25)
array2
as.vector(array2)
array2=array(0, dim=c(5,5));
as.vector(array2)
sp
size(sp)
length(sp)
sp=c(rep(0,99),abs(rnorm(100,mean=5,sd=10)), 200);
sp_ecdf= ecdf(sp);
pctile=sapply(sp,sp_ecdf)
str(sp)
str(pctile)
help(as.array)
htm = as.array(pctile, dim=c(10,20));
str(htm)
htm
htm = array(pctile, dim=c(10,20));
htm
plot(htm)
image(htm)
heatmap(htm)
install.packages('e1071',dependencies=T)
library(e1071)
ml_svm = list();
ml_svm.name='SVM'
ml_svm
ml_svm.name
ml_svm
ml_svm.name
ml_svm$name="SVM"
ml_svm
str(cats)
library(cats)
data(cats);
library(MASS)
data(cats)
cats
head(cats)
index <- 1:nrow(dataset)
data(cats);
library(cats)
dataset= cats
index <- 1:nrow(dataset)
str(index)
shuffle(str(index))
shuffle(index)
randomshuffle(index)
sample(index)
index <- sample(1:nrow(dataset));
partition
part
help(part)
seq(from=1, to=length(index), by=10)
help(seq)
seq(from=1, to=length(index), length.out=10)
seq.int(from=1, to=length(index), length.out=10)
seqint(from=1, to=length(index), length.out=10)
seq.int(1,100,11)
seq.int(1, length(index),10)
ptt = seq.int(1, length(index),10);
ptt
fromindex = ptt[-1];
fromindex
fromindex = ptt[-length(ptt)];
toindex = ptt[-1];
fromindex
toindex
length(fromindex)
length(toindex)
ptt = seq.int(1, length(index),10);
ptt
ptt = seq.int(1, length(index),length.out10);
ptt = seq.int(1, length(index),length.out=10);
ptt
ptt = floor(seq.int(1, length(index),length.out=10));
ptt
fromindex = ptt[-length(ptt)];
toindex = ptt[-1];
fromindex
toindex
toindex = ptt[-1]-1;   toindex[length(toindex)] = length(ptt);
toindex
length(index)
index <- sample(1:nrow(dataset));
ptt = floor(seq.int(1, length(index),length.out=10));
fromindex = ptt[-length(ptt)];
toindex = ptt[-1]-1;   toindex[length(toindex)] = length(index);
fromindex
toindex
-(fromindex:toindex)
fromindex:toindex
-(fromindex[1]:toindex[1])
testindex = index[c(fromindex:toindex),];
index
c(fromindex:toindex)
testindex = index[c(fromindex[ii]:toindex[ii]),];
ii=1;
testindex = index[c(fromindex[ii]:toindex[ii]),];
selection= fromindex[ii]:toindex[ii];
selection
testindex = index[selection,];
testindex = index[selection];
testindex
testset <- dataset[testindex,]
trainset <- dataset[-testindex,]
str(testset)
str(trainset)
numCV = 10;
str(numCV)
index <- sample(1:nrow(dataset));
ptt = floor(seq.int(1, length(index),length.out=numCV));
fromindex = ptt[-length(ptt)];
toindex = ptt[-1]-1;   toindex[length(toindex)] = length(index);
trainingdata = vector(list,length=numCV);
testingdata= vector(list,length=numCV);
list
trainingdata = vector("list",length=numCV);
testingdata= vector("list",length=numCV);
trainingdata
testingdata
trainingdata = vector("list",length=numCV);
testingdata= vector("list",length=numCV);
for (ii in 1:numCV) {
selection= fromindex[ii]:toindex[ii];
testindex = index[selection];
testingdata[ii] <- dataset[testindex,];
trainingdata[ii] <- dataset[-testindex,];
}
sss=list(training=trainingdata, testing=testingdata);
fromindex
fromindex[1]:toindex[4]
fromindex[1]:toindex[1]
ii=1
selection= fromindex[ii]:toindex[ii];
testindex = index[selection];
testingdata[ii] <- dataset[testindex,];
trainingdata[ii] <- dataset[-testindex,];
testingdata[[ii]] <- dataset[testindex,];
trainingdata[[ii]] <- dataset[-testindex,];
str(testingdata)
ii
for (ii in 1:numCV) {
selection= fromindex[ii]:toindex[ii];
testindex = index[selection];
testingdata[[ii]] <- dataset[testindex,];
trainingdata[[ii]] <- dataset[-testindex,];
}
fromindex
toindex
ii=2
selection= fromindex[ii]:toindex[ii];
''
selection= fromindex[ii]:toindex[ii];
testingdata[[ii]] <- dataset[testindex,];
trainingdata[[ii]] <- dataset[-testindex,];
str(testingdata)
Rcpp::sourceCpp('R/test.cpp')
install.packages('Rcpp')
Rcpp::sourceCpp('R/test.cpp')
timesTwo
library("parallel", lib.loc="C:/Program Files/R/R-3.2.3/library")
library("stats4", lib.loc="C:/Program Files/R/R-3.2.3/library")
timesTwo(c(500,40,50,30,20))
vignette("Rcpp-package")
vignette("Rcpp-introduction")
vignette("Rcpp-introduction")
vignette("Rcpp-introduction")
setwd("C:/Users/baeks/Google Drive/VisualStudioProject/Ultima3CharacterEditor/R")
library(EBImage);
loadTiles <- function(tilefile, numtiles, hres=16, vres=16, width=4) {
#tilefile = 'Shapes.tiff';
tileimage = readImage(tilefile); # 64 * 320 * 3
tiles <- lapply(1:numtiles,
function(ii) {
h= (ii-1)%%width;
v= (ii-1)%/%width;
imgmat= tileimage@.Data[(h*hres+1):(h*hres+hres),(v*vres+1):(v*vres+vres),];
Image(imgmat, dim=c(dim(imgmat)[1],dim(imgmat)[2],3), colormode='Color');
})
tiles;
}
convertUltima3MapToTiff<- function(mapfile, mapwidth=64, mapheight=64,divisor=4) {
remaining <- NA;
tifffile = gsub('.ULT','.tiff',basename(mapfile));
#  if (!file.exists(tifffile)) {
hres=16; vres=16; width = 4;
maplength=mapwidth*mapheight;
tiles <- loadTiles('Shapes.tiff',80, hres=hres, vres=vres, width=width);
numtiles = length(tiles);
dat<-readBin(mapfile,"raw",n=maplength*2);
mapdat = as.numeric(dat[1:maplength]);
remaining = dat[(maplength+1):length(dat)]
mat = array(mapdat%/%divisor, c(mapwidth,mapheight))+1;    # somehow, need to divide codes by 4 to get the correct tile number
rem = array(mapdat%%divisor, c(mapwidth,mapheight));    # somehow, need to divide codes by 4 to get the correct tile number
canvas = array(0, c(mapwidth*hres, mapheight*vres,3))
for (x in 1:maplength) {
h = (x-1) %% mapwidth + 1;
v = (x-1) %/% mapwidth + 1;
mm= mat[x];
canvas[((h-1)*hres+1):((h-1)*hres+hres),((v-1)*vres+1):((v-1)*vres+vres),] <- tiles[[mm]]@.Data;
}
im <- Image(canvas, dim=c(hres*mapwidth,vres*mapheight,3), colormode='Color');
writeImage(im, tifffile,bits.per.sample=8)
#  }
remaining;
}
convertUltima3Conflict2Tiff<- function(mapfile) {
remaining = convertUltima3MapToTiff(mapfile, mapwidth=11, mapheight=11,divisor=1);
}
mapfile = 'D://GOG Galaxy//Games//Ultima 3//SOSARIA.ULT';
mapwidth=64; mapheight=64;divisor=4;
convertUltima3MapToTiff('D://GOG Galaxy//Games//Ultima 3//SOSARIA.ULT');
mapfile = 'D://GOG Galaxy//Games//Ultima 3//SOSARIA.ULT';
mapwidth=64; mapheight=64;divisor=4;
rem<-convertUltima3MapToTiff(mapfile);
mapfile = 'YEW.ULT';
mapwidth=64; mapheight=64;divisor=4;
rem<-convertUltima3MapToTiff(mapfile);
rem
rem[380]
rem[381]
rem[382]
rem[385]
rem[384]
rem[385:(385+31)]
rem<-as.numeric(convertUltima3MapToTiff(mapfile));
npcshape = rem[385:(385+31)];
npcshape
npcshape = rem[385:(385+31)] / 4;
npcshape
